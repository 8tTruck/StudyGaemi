![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/9035dd0d-fe5f-495a-9b38-0b2ad55c3d0e)
![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/b16d8daa-f3b9-440f-aa2c-fa4455d1adc9)


## 1. 프로젝트 소개

---
> ![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/5dde081c-2d60-46d5-8f04-3a2923f0aa13)

> 프로젝트명 : 공부하개미

> 프로젝트 진행 기간: 2024.05.28 - 2024.07.04.

> 개발언어 : Swift


**🐜🐜🐜 공부하개미**는?

**공부 시간을 기록**하여 목표 성취를 돕고 **기상 알람** 기능을 더한 **교육 목적의 생산성 어플리케이션**입니다.

**알람**을 듣고 일어나 **공부**를 마치는 하루의 시작과 끝을 저희 **공부하개미**와 함께하세요.

매일 공부 시간을 스스로 조절하여, 부담감없이 성취감만으로 **올바른 습관**을 자연스럽게 형성해 나갈 수 있어요!

## 2. 주요 기능

---

### 🔑  공부하개미에 로그인 해보세요.

|로그인  |회원가입
|:-:  |:-:
|![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/9137e075-b470-4c66-b60d-1d693271683f)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/f29c1a10-b1c0-4740-8e55-12f2b307b649)

- **이메일 인증 회원가입** : 회원가입 절차에 따라 입력하신 이메일로 인증 링크를 보내드립니다.
- **간편 로그인(애플, 카카오)** : 애플 ID, 카카오 ID를 통해 간편하게 **공부하개미**를 이용할 수 있어요.
- **자동 로그인** : 언제나 빠르게 메인 화면으로 이동시켜드려요.
- **ID찾기** : 이메일을 입력하시면 기존 회원인지 빠르게 조회해드려요.
- **PW찾기** : 기존 회원이시라면 해당 이메일로 비밀번호 재설정 이메일을 보내드려요.

### **☀️ 기상하개미에서 여러분의 상쾌한 아침을 도와드려요.**

|알람시간  |알람설정  |문제화면
|:-:  |:-:  |:-:
|![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/78667b4e-1815-47b1-936e-c797de1cdeab)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/1e2dae6a-04e2-4b57-9738-36560ad530f4)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/8e80ad81-53d9-4ec4-bd97-cab846e7548e)

- **알람 설정** : 알람을 On/Off 할 수 있어요.
    - **시간** : 첫 알람이 울리는 시간을 설정할 수 있어요.
    - **문제 난이도** : 사칙 연산의 난이도를 설정할 수 있어요.
    - **알림음** : 어떤 음악을 들으며 일어날지 고를 수 있어요.
    - **반복** : 몇 분 간격, 몇 회 반복을 설정할 수 있어요.
- **기상개미** : 설정한 시간에 일어나고 문제를 맞출 경우 귀여운 기상개미를 획득할 수 있어요.

### **⏳ 공부하개미에서 성취를 통해 습관을 길러보아요.**

|공부타이머  |타이머실행  |공부개미 획득
|:-:  |:-:  |:-:
|![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/c6164c95-2e1f-498c-b5ef-eb937b2764a6)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/5d1d5b92-e890-49aa-a0f3-3813d8a28b4a)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/a4f5bb3e-b9a2-46dd-a9aa-aa9530d4b738)

- **공부 시간** : 오늘의 목표 시간을 자유롭게 정해보세요.
- **공부 시작** : ‘공부 시작하기’를 눌러 오늘의 공부를 시작해보세요.
- **공부 중지** : 잠시 휴식이 필요할 때는 언제든 멈출 수 있어요.
- **공부 종료** : 오늘의 공부가 끝났다면 결과 창으로 이동해보세요.
- **공부 개미** : 공부 종료 시점에, 목표 시간보다 많이 공부했다면 귀여운 공부개미를 획득할 수 있어요!

 

### 🗓️ 월간개미에서 나의 노력을 한 눈에 볼 수 있어요.

|캘린더  |완벽개미 획득
|:-:  |:-:
|![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/afa0a6e6-124a-43a4-a84f-c2b7d75ff255)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/6313f2d0-e002-44bc-a916-fbb5ec99c620)

- **완벽개미** : 기상개미와 공부개미를 모두 획득한 날은 완벽개미로 변해요.
    - 완벽개미 획득 : 완벽개미를 획득할 경우 귀여운 알림창을 보여줘요.
    
- **캘린더** : 기상개미와 공부개미를 획득한 날짜를 확인할 수 있어요.
    - 이 달의 완벽개미 : 우측 상단에서 이번 달에 획득한 완벽개미 수를 보여줘요.
    - 지난 개미 : 좌우로 스와이프하여 이전에 획득한 개미들도 볼 수 있어요.
- **연속개미** : 캘린더 하단에서 연속으로 성공중인 개미를 확인할 수 있어요.

### 👤 개ME에서 내 정보를 수정할 수 있어요.

|개ME  |친구초대  |도움말
|:-:  |:-:  |:-:
|![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/21c644f9-f33d-4cb1-aa7b-63d63d1bef87)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/ef3d630a-3243-481d-98b9-b4701ce76147)  |![image](https://github.com/8tTruck/StudyGaemi/assets/133753824/83c4bb4c-d47e-40d4-9245-1db39f01ea49)

- **내정보 수정** : 프로필 사진과 닉네임을 바꿀 수 있어요.
- **총 공부시간** : 내가 공부한 시간을 확인할 수 있어요.
- **비밀번호 변경** : 비밀번호를 변경할 수 있어요.
- **친구초대** : 앱 링크를 통해 친구를 앱에 초대할 수 있어요.
- **도움말** : 앱 사용설명서를 볼 수 있어요.

- `푸시 알람`
    
    <img src="https://github.com/8tTruck/StudyGaemi/assets/133753824/a2aa0a35-5ae8-491e-98e5-bb797da76508.png" width="200" height="400"/>
    <img src="https://github.com/8tTruck/StudyGaemi/assets/133753824/d07aee04-8155-4d2e-9ebf-46e928bf20d4.png" width="200" height="400"/>

    - **기상하개미**에서 설정한 시간에 알람음과 함께 푸시알림이 떠요.
    
    - 앱을 종료하면 푸시알림이 떠요.
- `다크 모드`
    
    <img src="https://github.com/8tTruck/StudyGaemi/assets/133753824/0eca256a-bf97-4453-bea6-f4663cb0d07f.png" width="200" height="400"/>
    <img src="https://github.com/8tTruck/StudyGaemi/assets/133753824/0f15de76-74e2-47b5-9c3d-6ddb455f0101.png" width="200" height="400"/>
    
    - ‘라이트 모드’와 ‘다크 모드’가 존재하며 해당 설정은 유저의 시스템 설정을 따라 유기적으로 전환됩니다.

## 3. 기술 스택

---

| 범위 | 기술 이름 |
| --- | --- |
| 의존성 관리 도구 | SPM |
| 협업 도구 | GitHub, Git |
| 아키텍처 | MVC |
| 디자인 패턴 | Singleton, Delegate |
| 인터페이스 | UIKit, AVFoundation, Then , FSCalendar (iOS 15.0 +) |
| 레이아웃 구성 | SnapKit |
| 내부 저장소 |  UserDefaults, CoreData |
| 코드 스타일 | swiftStyleGuide, SwiftAPI  |
| 외부 패키지 | Firebase, KakaoOpenSDK |

## 4. 기술적 의사결정

---

### Architecture

**MVC** 

**-** iOS 개발자에게 가장 친숙한 모델 패턴으로 팀원들 간 수월한 코드 리뷰 가능

- Controller에 들어갈 기능의 수가 적을 경우, View와 Controller를 ViewController로 통합하여 사용

### CoreData

CoreData를 사용하여, 기상 알람시간을 저장할 수 있도록 했습니다.

- **💡 CoreData 사용 이유**
    - 알람시간은 사용자들끼리 공유해야하는 사항이 아니기 때문에, 내부 DB만으로 기능 구현이 가능
    - AlarmCoreDataManager 클래스 싱글톤 패턴을 이용하여 Create, Read, Delete 메소드 구현
        - `AlarmCoreDataManager`
            
            ```swift
            class AlarmCoreDataManager {
                static let shared = AlarmCoreDataManager()
                var coreData: AlarmModel?
                private init() {}
                
                // MARK: - 코어데이터 context
                private let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext
                
                // MARK: - 알람 저장 메소드
                func saveAlarm(alarm: AlarmModel) {
                    let fetchRequest: NSFetchRequest<Alarm> = Alarm.fetchRequest()
                    
                    do {
                        let alarms = try context.fetch(fetchRequest)
                        
                        for alarm in alarms {
                            context.delete(alarm)
                        }
                        
                        let newAlarm = Alarm(context: context)
                        newAlarm.time = alarm.time
                        newAlarm.difficulty = alarm.difficulty
                        newAlarm.sound = alarm.sound
                        newAlarm.repeatEnabled = alarm.repeatEnabled ?? false
                        newAlarm.repeatInterval = alarm.repeatInterval
                        newAlarm.repeatCount = alarm.repeatCount
                        
                        try context.save()
                        
                        self.fetchAlarm()
                    } catch {
                        print("알람 저장 실패 에러: \(error)")
                    }
                }
                
                // MARK: - 알람 불러오기 메소드
                func fetchAlarm() {
                    let fetchRequest: NSFetchRequest<Alarm> = Alarm.fetchRequest()
                    
                    do {
                        let alarms = try context.fetch(fetchRequest)
                        
                        if let alarm = alarms.first {
                            self.coreData = AlarmModel(
                                time: alarm.time ?? Date(),
                                difficulty: alarm.difficulty ?? "",
                                sound: alarm.sound ?? "",
                                repeatEnabled: alarm.repeatEnabled,
                                repeatInterval: alarm.repeatInterval,
                                repeatCount: alarm.repeatCount
                            )
                        }
                    } catch {
                        print("알람 불러오기 실패 에러: \(error)")
                    }
                }
                
                // MARK: - 알람 삭제 메소드
                func deleteAlarm() {
                    let fetchRequest: NSFetchRequest<Alarm> = Alarm.fetchRequest()
                    
                    do {
                        let alarms = try context.fetch(fetchRequest)
                        
                        AlarmSettingController.shared.removeScheduleAlarm {
                            UserDefaults.standard.removeObject(forKey: "toggleButtonState")
                            
                            for alarm in alarms {
                                self.context.delete(alarm)
                            }
                            
                            do {
                                try self.context.save()
                                print("알람이 성공적으로 삭제되었습니다.")
                            } catch {
                                print("알람 삭제 후 저장 실패: \(error)")
                            }
                        }
                    } catch {
                        print("알람 삭제 실패 에러: \(error)")
                    }
                }
                
                // MARK: - 알람 데이터 반환 메소드
                func getAlarmData() -> AlarmModel {
                    self.fetchAlarm()
                    guard let alarmData = self.coreData else {
                        return AlarmModel(time: Date(), difficulty: "중", sound: "알림음 1")
                    }
                    return alarmData
                }
            }
            
            ```
            
- CoreData 설계도
    - Alarm 데이터 모델
        
        
        | Attribute | Type |  |
        | --- | --- | --- |
        | time | Date | 알람 시간 |
        | sound | String | 알람 소리 |
        | difficulty | String | 알람 문제 난이도 |
        | repeatEnabled | Boolean | 반복 설정 |
        | repeatInterval | String | 반복 간격 ex) 5분 마다 |
        | repeatCount | String | 반복 횟수 ex) 3회 반복 |

### FireBase

FireBase를 사용하여, 사용자별로 데이터를 넘겨받아 데이터를 관리할 수 있도록 했습니다.

- **💡** FireBase **사용 이유**
    - **Authentication 기능 사용**
        - 소셜로그인과 자체 회원가입 로그인 기능을 구현하기 위해서 사용
        - AuthenticationManager 클래스 싱글톤 패턴을 이용해 회원가입, 로그인, 로그아웃, 회원탈퇴 메소드를 구현
            - `AuthenticationManager`
                
                ```swift
                class AuthenticationManager {
                    
                    static let shared = AuthenticationManager()
                    
                    private init() { }
                    
                    private let db = Firestore.firestore()
                    
                    // MARK: - 회원가입
                    func createUser(email: String, password: String) {
                        Auth.auth().createUser(withEmail: email, password: password) { authResult, error in
                            if let error = error {
                                // 회원가입 실패 처리
                                print("회원가입 실패 에러: \(error.localizedDescription)")
                                return
                            }
                            // 로그인
                            Auth.auth().signIn(withEmail: email, password: password) { (authResult, error) in
                                if let error = error {
                                    print("로그인 실패 에러: \(error.localizedDescription)")
                                } else if let user = authResult?.user {
                                    print("로그인 성공: \(user.email ?? "")")
                                    FirestoreManager.shared.createUserData(email: email, nickName: email, loginMethod: "Firebase")
                                }
                            }
                            
                            // 이메일 인증 코드 전송
                            self.sendEmail(authResult: authResult)
                        }
                    }
                    
                    // MARK: - 로그인
                    func signIn(email: String, password: String) {
                        Auth.auth().signIn(withEmail: email, password: password) { (authResult, error) in
                            if let error = error {
                                print("로그인 실패 에러: \(error.localizedDescription)")
                            } else if let user = authResult?.user {
                                self.checkEmailVerifiedForLogin { isEmailVerified in
                                    if isEmailVerified {
                                        print("로그인 성공: \(user.email ?? "")")
                                        // 인증이 완료된 사용자를 위한 추가 로직
                                    } else {
                                        print("이메일 인증이 필요합니다. 이메일을 확인해주세요.")
                                        // 로그아웃 처리
                                        do {
                                            try Auth.auth().signOut()
                                        } catch let signOutError as NSError {
                                            print("Error signing out: \(signOutError.localizedDescription)")
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    ...
                }
                ```
                
    - **Cloud Firestore 기능 사용**
        - 사용자 별로 기상성공, 공부성공의 데이터 값을 관리하기 쉽도록 사용
        - 추후에 구현할 저장된 공부시간을 월별 랭킹을 보여주는 기능을 구현하기 위해서 사용
        - FirestoreManager 클래스 싱글톤 패턴을 이용해 데이터 CRUD 메소드를 구현
        - `FirestoreManager`
            
            ```swift
            final class FirestoreManager {
                static let shared = FirestoreManager()
                
                private init() { }
                
                private let db = Firestore.firestore()
                
                // 외부에서 Firestore 데이터베이스에 접근할 수 있도록 메서드 추가
                    func getDatabase() -> Firestore {
                        return db
                    }
                
                // MARK: - User 데이터 생성하기
                func createUserData(email: String, nickName: String, loginMethod: String) {
                    if let UID = Auth.auth().currentUser?.uid {
                        let user = UserModel(
                            UID: UID,
                            email: email,
                            nickName: nickName,
                            loginMethod: loginMethod
                        )
                        
                        do {
                            try db.collection("User").document(UID).setData(from: user, merge: true)
                        } catch let error {
                            print("Firestore 데이터 생성 에러: \(error)")
                        }
                    }
                }
                
                // MARK: - WakeUp 데이터 생성하기
                func createWakeUpData(success: Bool) {
                    if let UID = Auth.auth().currentUser?.uid {
                        let userRef = db.collection("User").document(UID)
                        let wakeUp = WakeUpModel(
                            userRef: userRef,
                            success: success,
                            date: Timestamp(date: Date())
                        )
                        
                        do {
                            try db.collection("WakeUp").addDocument(from: wakeUp)
                        } catch let error {
                            print("Firestore 데이터 생성 에러: \(error)")
                        }
                    }
                }
                
                // MARK: - Study 데이터 생성하기
                func createStudyData(success: Bool, during: Int) {
                    if let UID = Auth.auth().currentUser?.uid {
                        let userRef = db.collection("User").document(UID)
                        let study = StudyModel(
                            userRef: userRef,
                            success: success,
                            date: Timestamp(date: Date()),
                            during: during
                        )
                        
                        do {
                            try db.collection("Study").addDocument(from: study)
                        } catch let error {
                            print("Firestore 데이터 생성 에러: \(error)")
                        }
                    }
                }
                
                ...
            }
            ```
            
- Firestore Database 설계
    - User 데이터베이스
        
        
        | 변수명 | 타입 |  |
        | --- | --- | --- |
        | UID | String | Primary Key |
        | email | String |  |
        | loginMethod | String |  |
        | nickName | String |  |
    - WakeUp 데이터베이스
        
        
        | 변수명 | 타입 |  |
        | --- | --- | --- |
        | userRef | String | Foreign Key |
        | date | Timestamp | 자정 기준으로 |
        | success | Bool |  |
    - Study 데이터베이스
        
        
        | 변수명 | 타입 |  |
        | --- | --- | --- |
        | userRef | String | Foreign Key |
        | date | Timestamp | 새벽 5시 기준으로 |
        | success | Bool |  |
        | during | number |  |
    - Alert 데이터베이스
        
        
        | 변수명 | 타입 |  |
        | --- | --- | --- |
        | userRef | String | Foreign Key |
        | date | Timestamp | 자정 기준으로 |
        | state | number |  |

### UserDefaults

UserDefaults를 사용하여 프로필 사진의 경로를 저장합니다.

- CoreData 대신 UserDefaults를 사용한 이유
    - UserDefaults는 간단한 키-값 저장소로 빠르고 쉽게 소규모 데이터를 저장하고 접근할 수 있기 때문에 사용하였습니다. 반면, Core Data는 더 복잡한 데이터 구조와 관계형 데이터를 다루기 위한 것으로, 간단한 데이터 저장에 비해 과한 선택입니다.
- UserDefaults Database설계
    - **Key**: `profileImagePath`
    - **Value**: 프로필 이미지가 저장된 파일의 경로를 문자열로 저장합니다.

### SnapKit & Then

- **💡 SnapKit 사용 이유**
    - AutoLayout 코드 작성을 간결하게 하고, 코드 가독성을 높이기 위해 사용했습니다.
        - `SnapKit` 사용 예시
            
            ```swift
                override func constraintLayout() {
                    imageView.snp.makeConstraints { make in
                        make.width.height.equalTo(22)
                    }
                    
                    alarmView.snp.makeConstraints { make in
                        make.top.equalTo(view.safeAreaLayoutGuide.snp.top).offset(34)
                        make.centerX.equalToSuperview()
                        make.leading.trailing.equalTo(view.safeAreaLayoutGuide).inset(24)
                        make.height.equalTo(66)
                    }
                    
                    notificationStackView.snp.makeConstraints { make in
                        make.top.equalTo(alarmView.snp.top).inset(14)
                        make.bottom.equalTo(alarmView.snp.bottom).inset(14)
                        make.leading.equalTo(alarmView.snp.leading).inset(18)
                        make.trailing.equalTo(alarmView.snp.trailing).inset(18)
                    }
                    
                    notificationImageView.snp.makeConstraints { make in
                        make.width.equalTo(38)
                        make.height.equalTo(38)
                    }
                    
                    alarmButton.snp.makeConstraints { make in
                        make.centerY.equalToSuperview()
                        make.centerX.equalToSuperview()
                        make.width.equalTo(312)
                        make.height.equalTo(312)
                    }
                    
                    stackView.snp.makeConstraints { make in
                        make.bottom.equalTo(view.safeAreaLayoutGuide.snp.bottom).inset(45)
                        make.centerX.equalToSuperview()
                        make.leading.trailing.equalTo(view.safeAreaLayoutGuide).inset(24)
                        make.height.equalTo(52)
                    }
                }
            ```
            
- **💡 Then 사용 이유**
    - 인스턴스 초기화 시 클로저보다 가독성을 좋게 하기 위해 사용했습니다.
        - `Then` 사용 예시
            
            ```swift
                private let imageView = UIImageView().then {
                    $0.image = UIImage(named: "mainAnt")
                    $0.contentMode = .scaleAspectFit
                }
                
                private let alarmView = UIView().then {
                    $0.backgroundColor = UIColor(named: "alertBackgroundColor")
                    $0.layer.cornerRadius = 23
                    $0.layer.shadowColor = UIColor(named: "pointBlack")?.cgColor
                    $0.layer.shadowOffset = CGSize(width: 0.0, height: 0.0)
                    $0.layer.shadowRadius = 5.0
                    $0.layer.shadowOpacity = 0.15
                }
                
                private let notificationStackView = UIStackView().then {
                    $0.axis = .horizontal
                    $0.spacing = 10
                }
                
                private let notificationImageView = UIImageView().then {
                    $0.image = UIImage(named: "sleepAnt")
                    $0.contentMode = .scaleAspectFit
                    $0.setContentHuggingPriority(.defaultHigh, for: .horizontal)
                    $0.setContentCompressionResistancePriority(.defaultHigh, for: .horizontal)
                }
                
                private let verticalStackView = UIStackView().then {
                    $0.axis = .vertical
                    $0.setContentHuggingPriority(.defaultLow, for: .horizontal)
                }
                
                private let horizontalStackView = UIStackView().then {
                    $0.axis = .horizontal
                    $0.distribution = .equalCentering
                }
            ```
            

### FSCalendar

- **💡 FSCalendar 사용이유**
    - CalendarView는 iOS 16이상에서 사용가능한데 프로젝트의 최소 지원 버전은 iOS15이기 때문에 사용이 불가함
    - FSCalendar는 커스텀 옵션이 풍부하고 사용이 비교적 쉬움
        - `예시코드`
            
            ```swift
             private lazy var calendarView = FSCalendar().then {
                    $0.dataSource = self
                    $0.delegate = self
                    
                    //셀등록
                    $0.register(CalendarCell.self, forCellReuseIdentifier: "CalendarCell")
                    
                    // 첫 열을 월요일로 설정
                    $0.firstWeekday = 2
                    $0.scope = .month
                    
                    $0.scrollDirection = .horizontal
                    $0.locale = Locale(identifier: "ko_KR")
                    
                    // 현재 달의 날짜들만 표기하도록 설정
                    $0.placeholderType = .none
                    
                    // 양옆 년도, 월 지우기
                    $0.appearance.headerMinimumDissolvedAlpha = 0.0
                    
                    // 헤더뷰 설정
                    $0.headerHeight = 50
                    $0.appearance.headerDateFormat = "MM월"
                    $0.appearance.headerTitleColor = .black
                    $0.appearance.headerTitleAlignment = .left
                    $0.appearance.headerMinimumDissolvedAlpha = 0.0
                    
                    // 요일 UI 설정
                    $0.weekdayHeight = 16
                    $0.appearance.weekdayFont = UIFont(name: CustomFontType.regular.name, size: 14) ?? UIFont.systemFont(ofSize: 14, weight: .bold)
                    $0.appearance.weekdayTextColor = .fontGray
                    
                    // 날짜 UI 설정
                    $0.appearance.titleTodayColor = .black
                    $0.appearance.titleFont = UIFont(name: CustomFontType.regular.name, size: 16) ?? UIFont.systemFont(ofSize: 16, weight: .bold)
                    
                    //날짜 선택시
                    $0.today = nil
                    $0.appearance.selectionColor = .clear // 사용자가 선택한 날짜
                    $0.appearance.titleSelectionColor = .fontBlack // 선택한 날짜 글자색
                    $0.allowsSelection = false
                    
                }
            ```
            

## 5. 트러블 슈팅

---

### 중복 코드 최소화

> BaseViewController, CustomView, 싱글톤 패턴을 활용하여 **중복 코드를 최소화** 하려 노력했습니다.
> 
- **💡 BaseViewController**
    - 모든 뷰에서 기본적으로 사용하는 메소드를 추가
    - `configureUI()`, `constraintLayout()`, `hideKeyboardWhenTappedAround()`, `…`
        
        ```swift
        class BaseViewController: UIViewController {
        
            override func viewDidLoad() {
                super.viewDidLoad()
                self.configureUI()
                self.constraintLayout()
                self.hideKeyboardWhenTappedAround()
            }
            
            func configureUI() {
                view.backgroundColor = UIColor(named: "viewBackgroundColor")
                // UIButton이나 UILabel 등과 같은 부분 초기 설정 함수
            }
            
            func constraintLayout() {
                // UIButton이나 UILabel 등과 같은 부분 제약조건 설정 함수
            }
        
        }
        
        // 빈 화면 터치 시 키보드 내려가는 기능 추가
        extension BaseViewController {
            func hideKeyboardWhenTappedAround() {
                let tap = UITapGestureRecognizer(target: self, action: #selector(BaseViewController.dismissKeyboard))
                tap.cancelsTouchesInView = false
                view.addGestureRecognizer(tap)
            }
            
            @objc func dismissKeyboard() {
                view.endEditing(true)
            }
        }
        
        extension UIButton {
            
            func addTouchAnimation() {
                self.addTarget(self, action: #selector(buttonTouchDown), for: .touchDown)
                self.addTarget(self, action: #selector(buttonTouchUp), for: [.touchUpInside, .touchUpOutside, .touchCancel])
            }
            
            @objc private func buttonTouchDown(sender: UIButton) {
                UIView.animate(withDuration: 0.1) {
                    sender.transform = CGAffineTransform(scaleX: 1.01, y: 1.01)
                }
                sender.isHighlighted = false
            }
            
            @objc private func buttonTouchUp(sender: UIButton) {
                UIView.animate(withDuration: 0.1) {
                    sender.transform = .identity
                }
                sender.isHighlighted = false
            }
        }
        
        extension UITextField {
            func shake() {
                let animation = CAKeyframeAnimation(keyPath: "position")
                animation.duration = 0.05
                animation.values = [
                    NSValue(cgPoint: CGPoint(x: self.center.x - 2, y: self.center.y)),
                    NSValue(cgPoint: CGPoint(x: self.center.x + 2, y: self.center.y))
                ]
                animation.autoreverses = true
                animation.repeatCount = 8
                self.layer.add(animation, forKey: "shake")
            }
            
        }
        ```
        
- **💡 CustomView**
    - 자주 사용되는 View들을 미리 제작해놓고, 불러와서 사용하는 방식
    - `CustomButton`
        
        ```swift
        class CustomButton: UIButton {
        
            let gradient = CAGradientLayer().then {
                $0.colors = [UIColor(named: "pointOrange")?.cgColor ?? UIColor.orange.cgColor,
                             UIColor(named: "pointYellow")?.cgColor ?? UIColor.yellow.cgColor]
                $0.startPoint = CGPoint(x: 0.0, y: 0.5)
                $0.endPoint = CGPoint(x: 1.0, y: 0.5)
            }
        
            init(x: Int = 0, y: Int = 0, width: Int = 334, height: Int = 52, radius: CGFloat = 10, title: String = "저장") {
                super.init(frame: CGRect(x: x, y: y, width: width, height: height))
                
                self.layer.addSublayer(gradient)
                self.layer.cornerRadius = radius
                self.clipsToBounds = true
                self.setTitle(title, for: .normal)
                self.titleLabel?.font = UIFont(name: CustomFontType.regular.name, size: 20) ?? UIFont.systemFont(ofSize: 20)
                self.setTitleColor(.white, for: .normal)
            }
            
            required init?(coder: NSCoder) {
                fatalError("init(coder:) has not been implemented")
            }
            
            override func layoutSubviews() {
                super.layoutSubviews()
                gradient.frame = self.bounds
            }
            
            func setFontColor(_ color: UIColor?, for uiColor: UIControl.State) {
                self.setTitleColor(color, for: uiColor)
            }
            
            func setBackgroundColor(_ color: UIColor?) {
                gradient.removeFromSuperlayer()
                self.backgroundColor = color
            }
            
            func setFontSize(name: String,_ size: CGFloat) {
                self.titleLabel?.font = UIFont(name: name, size: size)
            }
        }
        ```
        
    - `CustomTextField`
        
        ```swift
        class CustomTextField: UITextField {
        
            init(x: Int = 0, y: Int = 0, width: Int = 342, height: Int = 52, text: String = "정답을 적어보개미") {
                super.init(frame: CGRect(x: x, y: y, width: width, height: height))
                
                self.placeholder = text
                self.tintColor = UIColor.systemBackground
                self.textColor = UIColor(named: "fontGray") ?? UIColor.gray
                self.layer.borderColor = UIColor(named: "textFieldColor")?.cgColor ?? UIColor.gray.cgColor
                self.layer.borderWidth = 1.5
                self.layer.cornerRadius = 10
                
                let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: 15, height: frame.height))
                self.leftView = paddingView
                self.leftViewMode = ViewMode.always
                self.rightView = paddingView
                self.rightViewMode = ViewMode.always
                
            }
            
            required init?(coder: NSCoder) {
                fatalError("init(coder:) has not been implemented")
            }
            
        }
        
        ```
        
- **💡 싱글톤 패턴**
    - 자주 사용되는 메소드를 싱글톤 패턴을 이용해, 매번 클래스를 생성하지 않도록 구현했습니다.
    - `AlarmCoreDataManager`, `AuthenticationManager`, `FirestoreManager`
        
        ```swift
        AlarmCoreDataManager.shared.fetchAlarm()
        AuthenticationManager.shared.createUser()
        FirestoreManager.shared.createWakeUpData()
        ```
        

### 프로젝트 개발 중 이슈

- Firebase 데이터베이스 계정생성 수정
    - ***문제점***
        - 기존에는  User 데이터베이스 생성 시 UID 대신에 email로 생성이 되도록 했는데, appleID로 로그인 시 이메일 숨기기 기능을 활성화 시키면 email값을 넣을 수 없는 현상이 발생했습니다.
    - ***해결방안***
        - 계정 생성시 자동으로 생성되는 UID값을 email 대신에 넣는것으로 해결할 수 있다고 판단했습니다.
    - ***결과***
        - 데이터베이스 생성을 UID로 바꾸면서 User, WakeUp, Study 데이터베이스 CRUD 부분을 전부 수정
        - appleID 뿐만 아니라 다른 소셜로그인을 추가할 때, 손쉽게 추가할 수 있다는 장점이 생김
        - 추후에 이메일을 변경하는 일이 생기더라도 데이터베이스에서 사용자를 식별하는 데 문제가 생기지 않음
        
- window.rootViewController 전환 시 멈추는 현상(RepeatingSecondsTimer)
    - ***문제점***
        - 팀원들이 개발 수정된 부분들을 머지한 후 단체로 테스트를 진행하는 과정에서, 로그아웃, 회원가입, 알람 기능으로 이동할 때 아래와 같은 에러가 발생했습니다
            
            ```swift
            Thread 1: EXC_BREAKPOINT (code=1, subcode=0x10444adf4)
            ```
            
        - 이 오류는 주로 메모리 관리가 잘못되었을 때 나타나는 에러였습니다.
        - 머지 이후에 발생한 문제였기 때문에, 머지하기 전 수정된 코드를 검토하며 문제가 될 만한 부분을 찾았습니다.
    - ***해결방안***
        - 문제의 원인은 `RepeatingSecondsTimer.swift` 파일에서 Timer가 메모리에 할당되어 있지 않은 상태에서 `window.rootViewController`를 전환하려고 시도했기 때문이었습니다. Timer가 메모리에 없는데도 deinit에서 Timer를 제거하려고 해서 문제가 발생했습니다.
        - Timer를 실행시키지 않더라도, 앱이 실행될 때 메모리에 Timer를 할당하도록 수정하면 해결될 것이라고 판단했습니다.
    - ***결과***
        
        객체 생성 시 호출되는 init 부분을 추가하여 Timer 초기화 작업을 수행했습니다.
        
        ```swift
        init() {
                start(durationSeconds: 0)
        }
        ```
        
    
- 앱 삭제 후 실행 시 카카오 로그아웃 및 회원탈퇴가 안되는 현상
    - ***문제점***
        - 앱을 삭제 후 재설치한 후, 카카오 로그아웃이나 회원탈퇴를 시도할 때 앱이 멈추는 현상이 발생했습니다. 원인을 조사한 결과, 이는 Firebase와 카카오 로그인의 토큰 관리 방식의 차이에서 발생한 문제였습니다.
            - **Firebase 로그인:** 로그인 토큰이 Firebase 서버에 저장됩니다.
            - **카카오 로그인:** 로그인 토큰이 어플 내에 생성되어 저장됩니다.
        - 따라서, 앱을 삭제하면 카카오 로그인 토큰은 사라져 로그아웃 상태가 되지만, Firebase의 카카오 로그인 토큰은 여전히 서버에 남아 있어 일관되지 않은 상태가 됩니다.
    - ***해결방안***
        - 앱을 삭제하면 카카오 로그인 토큰이 사라지므로, Firebase에서도 동일한 조건이 되도록 설정하였습니다.
        - Firebase에 로그인되어 있지만 카카오 로그인 토큰이 없는 경우, 자동으로 View가 전환되지 않도록 하여 로그아웃이나 회원탈퇴를 시도할 수 없도록 조치했습니다.
    - ***결과***
        
        Firebase에 로그인된 상태라도 카카오 로그인 토큰이 없으면 자동으로 View 전환이 이루어지지 않도록 수정했습니다. 이를 통해 로그아웃이나 회원탈퇴를 시도하는 과정에서 앱이 멈추는 문제를 해결했습니다.
        
    
- 데이터와 UI 동기화 이슈
    - ***문제점***
        
        달력뷰에서 공부데이터와 기상데이터를 불러와 스탬프를 표시하는 과정에서 데이터를 불러오기도 전에 스탬프가 보이는 문제가 발생.
        
    - ***해결방안***
        - DispatchGroup을 사용하여 사용자의 공부데이터, 기상데이터를 각각 네트워크 통신을 통해 불러온 후, UI를 변경하는 작업을 진행하였습니다.
    - ***결과***
        
        ```swift
        private func setData() {
        
                var studiesData = [study]()
                var wakeupsData = [wakeup]()
                let dispatchGroup = DispatchGroup()
                
                dispatchGroup.enter()
                firestoreManager.readStudyData { result in
                    defer { dispatchGroup.leave() }
                    ...
                }
                
                dispatchGroup.enter()
                firestoreManager.readWakeUpData { result in
                    defer { dispatchGroup.leave() }
        	            ...
                    }
                }
                
                dispatchGroup.notify(queue: .main) {
                    self.studies = studiesData
                    self.wakeups = wakeupsData
                    self.updateData()
                    self.checkUserAlertStatus()
                    self.calendarView.reloadData()
                    self.badgeView.reloadData()
                }
            }
        ```

        
- 런치 스크린 사용 시 일시적 Blackout 발생
    - ***문제점***
        
        자동 로그인에 성공해 메인 화면을 띄우거나 로그인에 실패하여 로그인 화면을 띄울 동안 런치 스크린을 사용자에게 보여주는 것이 목표였으나, 다음 ViewController(메인 화면 or 로그인 화면)가 로드될때까지 런치 스크린을 띄우지 못함. 결국 자동 로그인을 식별하는동안 Delay가 발생하여 BlackOut 발생.
        
    - ***해결방안***
        
        기존 런치 스크린의 기능이 제한적이라 런치 스크린으로 사용할 새로운 View를 작성하여 `window`의 `rootViewController`를 `launchScreenView`로 설정했습니다. 로그인 여부를 판독하는 동안 띄워줄 View가 생겼으므로 기존의 런치스크린 → 블랙아웃 → 로그인 상태에 따른 뷰 가 아닌 런치 스크린 뷰 → 로그인 상태에 따른 뷰 로 흐름을 변경하였습니다.
        
    - ***결과***
        
        ```swift
        class SceneDelegate: UIResponder, UIWindowSceneDelegate {
        
            var window: UIWindow?
            var isLogined = false
        
            func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
                guard let windowScene = (scene as? UIWindowScene) else { return }
        
                let launchScreenView = LaunchScreenView()
        
                // Create a new UIWindow
                let window = UIWindow(windowScene: windowScene)
                window.rootViewController = launchScreenView
                window.makeKeyAndVisible()
                self.window = window
        
                if connectionOptions.notificationResponse == nil {
                    // 로그인 상태 확인 및 적절한 ViewController 설정
                    checkLogin()
                }
            }
        }
        
        class LaunchScreenView: UIViewController {
        
            override func viewDidLoad() {
                super.viewDidLoad()
                // 런치 스크린 코드 생략
            }
        }
        
        extension SceneDelegate {
            
            // MARK: - 특정 ViewController를 생성하는 메소드
            func createViewController(withIdentifier identifier: String) -> UIViewController? {
                if identifier == "AlarmQuestionView" {
                    let data = AlarmCoreDataManager.shared.getAlarmData()
                    let time = data.time
                    let calendar = Calendar.current
                    let currentDate = Date()
                    
                    let components = calendar.dateComponents([.minute], from: time, to: currentDate)
                    if let minuteDifference = components.minute {
                        if data.isRepeatEnabled {
                            for i in 0..<data.repeatCountInt {
                                let intervalTime = time.addingTimeInterval(TimeInterval(data.repeatIntervalMinutes * i * 60))
                                let intervalComponents = calendar.dateComponents([.minute], from: intervalTime, to: currentDate)
                                if let intervalMinuteDifference = intervalComponents.minute, intervalMinuteDifference >= 0, intervalMinuteDifference <= data.repeatIntervalMinutes + 2 {
                                    return AlarmQuestionView()
                                }
                            }
                        } else if minuteDifference >= 0, minuteDifference <= 2 {
                            return AlarmQuestionView()
                        }
                    }
                }
                return nil
            }
        }
        
        extension SceneDelegate {
            
            func checkLogin() {
                print("로그인 유저인지 확인")
                if let user = Auth.auth().currentUser {
                    print("currentUser임")
                    AuthenticationManager.shared.checkEmailVerifiedForLogin { isEmailVerified in
                        if isEmailVerified {
                            self.isLogined = true
                            print("애플 또는 이메일 자동 로그인 성공: \(user.email ?? "")")
                            self.navigateToMainScreen()
                        } else {
                            FirestoreManager.shared.getLoginMethod { loginMethod in
                                if loginMethod == "kakao" {
                                    print("카카오 계정 로그인 성공")
                                    self.isLogined = true
                                    self.navigateToMainScreen()
                                } else {
                                    print("카카오 계정 로그인 실패")
                                    self.navigateToLoginScreen()
                                }
                            }
                        }
                    }
                } else {
                    print("로그인 되어 있지 않음")
                    self.navigateToLoginScreen()
                }
            }
            
            
            func navigateToMainScreen() {
                let bottomTabBarVC = BottomTabBarViewController()
                if let window = self.window {
                    window.rootViewController = bottomTabBarVC
                    window.makeKeyAndVisible()
                }
            }
            
            func navigateToLoginScreen() {
                let loginvC = LoginViewController()
                let navController = UINavigationController(rootViewController: loginvC)
                if let window = self.window {
                    window.rootViewController = navController
                    window.makeKeyAndVisible()
                }
            }
        }
        
        ```

## 6. 참여자

---

[Team 8tTruck](https://www.notion.so/9d9656552e5c4b8cb6dc8820632a06ad?pvs=21)

## 7. 앞으로의 계획

---

- 사용자들 간 공부 시간의 총량을 비교해볼 수 있는 ‘랭킹개미’ 신규 론칭
- 공부타이머 위젯
- 신규 간편 로그인 방식 지원 (구글 로그인)
- 프로필 이미지 서버 연동
- 카테고리별 타이머 여러개 동작 가능하도록 구현
- 광고 삽입
- 서버를 구현해서 앱이 백그라운드 상태일때 소리가 재생되도록 알람 기능 업그레이드
- 기상 알람 문제 다양화
